[6장] 데이터 타입
===
* 자바스크립트의 모든 값은 데이터 타입을 가진다.
* 7개의 데이터 타입
* 원시 타입(primitive type), 객체 타입(object type)으로 분류
---
# 6.1 숫자 타입
* 부동소수점 형식을 따름 -> 모든 수를 실수로 처리
### [06-01]
```js
//모두 숫자 타입이다
var integer = 10; //정수
var double = 10.12; //실수
var negative = -20; //음의 정수
```
### [06-03]
```js
//숫자 타입은 모두 실수로 처리된다.
console.log(1 === 1.0); // true
console.log(4 / 2 ; //2
colsole.log(3 / 2); //1.5
```
### [06-04]
```js
console.log(10/0); //infinity
console.log(10/-0);//-infinity
console.log(1+'string');//NaN
```
---
# 6.2 문자열 타입(string)
* 텍스트 데이터
* 유니코드 문자(UTF-16)의 집합
* '',"",``으로 텍스트를 감싼다.
* 자바스크립트에서는 일반적으로 ''를 사용한다.
* 문자열을 따옴표로 감싸지 않으면, 엔진은 키워드나 식별자 같은 토큰으로 인식한다.
* 문자열이 생성되면 그 문자열을 변경할 수 없다.(11.1.2 문자열과 불변성에서 후술)

---
# 6.3 템플릿 리터럴(template literal)
* ``백틱을 사용해서 문자열을 표현한다. 
## 6.3.1 멀티라인 문자열
일반 문자열 내에서는 줄바꿈(개행)이 허용되지 않는다.
### [06-09]
```js
var str = 'Hello
world';
//SyntaxError
```
일반 문자열 내에서 줄바꿈 등의 공백을 표현하려면 \로 시작하는 이스케이프 시퀀스를 사용해야 한다. 
### [06-10]
```js
var template = '<ul>\n\t<li><a herf="#">Home</a></li>\n</ul>'
console.log(template);
```
=> 출력 결과 
```html
<ul>
    <li><a href="#">Home</a></li>
</ul>
```

### [06-11]
```js
var template = `<ul>
    <li><a herf="#">Home</a></li>
</ul>`;

console.log(template);
```
=>출력 결과
```html
<ul>
    <li><a href="#">Home</a></li>
</ul>
```
템플릿 리터럴 내에서는 이스케이프 시퀀스를 사용하지 않고도 줄바꿈이 허용되며, 모든 공백도 있는 그대로 적용된다. 

## 6.3.2 표현식 삽입
문자열은 문자열 연산자인 +를 사용해 연결할 수 있다.
### [06-12]
```js
var first = 'Cho-yeon';
var last = 'Kim';
console.log('My name is'+ first + ''+last +'.'); //My name is Cho-yeon Kim.
```
### [06-13]
```js
var first = 'Cho-yeon';
var last = 'Kim';
console.log(`My name is ${first} ${last}.`); //My name is Cho-yeon Kim.
```
표현식을 삽입하려면 ${}로 표현식을 감싼다. 

### [06-14,15]
```js
console.log(`1+2 = ${1+2}`); // 1+2 = 3
console.log('1+2 = ${1+2}'); // 1+2 = ${1+2}
```

---
# 6.4 불리언 타입(boolean)
* true, false
* 조건문에서 자주 사용한다. 
---

# 6.5 undefined 타입
* undefined 
* var 키워드로 선언한 변수는 undefined로 초기화된다. 
* 변수를 참조했을 떄, undefined가 반환된다면, 참조한 변수가 선언 이후 값이 할당된 적이 없다는 것이다.
* 자바스크립트 엔진이 변수를 초기화하는 데 사용하는 undefined를 개발자가 의도적으로 변수에 할당한다면 undefined의 본래 취지와 어긋나며 혼란을 야기할 수 있다
* 변수에 값이 없다는 것을 명시하고 싶을 때는 null을 할당한다. 
---
# 6.6 null 타입
* null
* 변수에 값이 없다는 것을 의도적으로 명시(의도적 부재intentional absence)할 때 사용한다.
* 변수에 null을 할당 -> 이전에 할당되어 있던 값에 대한 참조를 명시적으로 제거하는 것 -> 엔진은 가비지 콜렉션을 수행할 것.

```js
var foo = 'Lee';
//이전 참조를 제거. 변수 foo는 더이상 'Lee'를 참조하지 않는다.
foo = null;
```
### [06-19]
```html
<!DOCTYPE html>
<html>
    <body>
        <script>
            var element = document.querySeclector('.myClass');
            //HTML 문서에 myClass 클래스를 갖는 요소가 없다면 null을 반환한다. 
            console.log(element); //null
        </script>
    <body>
</html>
```
함수가 유효한 값을 반환할 수 없는 경우에도 명시적으로 null을 반환한다. 
---
# 6.7 심벌 타입
* ES6에서 추가된 7번째 타입. 
* 변경 불가능한 원시 타입의 값
* 다른 값과 중복되지 않는 유일무이한 값.
* 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용된다.
* 심벌 이외의 원시 값은 리터럴을 통해 생성하지만, 심벌은 Symbol 함수를 호출해 생성한다. 
* 이때 생성된 심벌 값은 외부에 노출되지 않으며, 다른 값과 절대 중복되지 않는다.
```JS
//심벌 값 생성
var key = Symbol('key');
console.log(typeof key); //symbol

//객체 생성
var obj = {};

//이름이 충돌할 위험이 없는 유일무이한 값인 심벌을 프로퍼티 키로 사용한다.
obj[key] = 'value';
console.log(obj[key]); //value

```
33장 7번째 타입 Symbol에서 자세히 후술

---
# 6.8 객체 타입
11장 원시 값과 객체의 비교 에서 자세히 후술

---
# 6.9 데이터 타입의 필요성
* 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
* 값을 참조할 때 한 번에 읽어 들여야 하는 메모리 공간의 크기를 결정하기 위해
* 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해

---
# 6.10 동적 타이핑
## 6.10.1 동적 타입 언어와 정적 타입 언어
__정적 타입 언어__ 
* C, C++, 자바, 코틀린 ... 
* 정적 타입 언어는 변수를 선언할 데이터 타입을 사전에 선언해야 한다. (: 명시적 타입 선언)
* 변수의 타입을 변경할 수 없으며, 변수에 선언한 타입에 맞는 값만 할당할 수 있다.
* 컴파일 시점에 타입 체크를 수행하고 타입 체크를 통과하지 못했다면 에러를 발생시켜 프로그램의 실행을 막는다.

```c
// c변수에는 1바이트 정수 타입의 값만 할당할 수 있다
char c;
// num 변수에는 4바이트 정수 타입의 값만 할당할 수 있다.
int num;
```
__동적 타입 언어__
* JS, 파이썬, PHP, 루비...
* 변수를 선언할 때 타입을 선언하지 않는다. 
* 값을 할당하는 시점에서 변수의 타입이 동적으로 결정되고, 변수의 타입을 언제든지 자유롭게 변경할 수 있다.

## 6.10.2 동적 타입 언어와 변수
* 변수 값은 언제든지 변경되 수 있기 때문에, 변수 값을 추적하기 어려울 수 있다.
* 자바스크립트 엔진이 암묵적으로 데이터 타입을 자동으로 변환하기도 한다.
* 동적 타입 언어는 유연성은 높지만 신뢰성은 떨어진다. 

⚠ 변수를 사용할 때 주의점 ⚠
>* 변수는 필요한 경우에 한해 제한적으로 사용한다. 
>* 변수의 유효 범위(스코프)는 최대한 좁게 만든다. 
>* 전역 변수는 최대한 사용하지 않는다. 
>* 변수보다는 상수를 사용해 값의 변경을 억제한다. (const 사용)
>* 변수이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍한다. 


